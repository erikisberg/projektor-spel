<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Pong - Projector Display</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      font-family: 'Helvetica Neue', Arial, sans-serif;
      overflow: hidden;
    }

    #gameContainer {
      position: relative;
      width: 100vw;
      height: 100vh;
      background: #000;
      border: 4px solid #fff;
    }

    canvas {
      display: block;
      background: #000;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    #adeprimoLogo {
      position: absolute;
      top: 2vh;
      left: 2vw;
      height: 6vh;
      opacity: 0.9;
      z-index: 100;
    }

    /* Waiting Screen */
    #waitingScreen {
      display: none;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      width: 100%;
      height: 100%;
      color: #fff;
    }

    #waitingScreen.show {
      display: flex;
    }

    #waitingScreen h1 {
      font-size: 15vw;
      font-weight: 300;
      margin-bottom: 40px;
      letter-spacing: 1vw;
    }

    #waitingScreen p {
      font-size: 4vw;
      font-weight: 300;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    /* Lobby Screen */
    #lobbyScreen {
      display: none;
      flex-direction: column;
      width: 100%;
      height: 100%;
      color: #fff;
    }

    #lobbyScreen.show {
      display: flex;
    }

    #lobbyScreen h1 {
      font-size: 6vw;
      font-weight: 300;
      text-align: center;
      padding: 30px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      letter-spacing: 0.3vw;
    }

    #playerList {
      flex: 1;
      display: flex;
      padding: 40px;
      gap: 40px;
    }

    .team-column {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .team-column h2 {
      font-size: 3vw;
      font-weight: 400;
      text-align: center;
      padding-bottom: 20px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.15);
      letter-spacing: 0.2vw;
    }

    .player-slot {
      padding: 30px;
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 2px;
      font-size: 2.5vw;
      font-weight: 300;
      text-align: center;
      transition: all 0.3s ease;
    }

    .player-slot.ready {
      background: #fff;
      color: #000;
      border-color: #fff;
      font-weight: 400;
    }

    #readyStatus {
      text-align: center;
      padding: 30px;
      font-size: 3.5vw;
      font-weight: 300;
      border-top: 1px solid rgba(255, 255, 255, 0.2);
      letter-spacing: 0.2vw;
    }

    /* Game Screen */
    #gameScreen {
      display: none;
      width: 100%;
      height: 100%;
    }

    #gameScreen.show {
      display: block;
    }

    #scoreBoard {
      position: absolute;
      top: 4vh;
      width: 100%;
      display: flex;
      justify-content: space-around;
      color: #fff;
      font-size: 8vw;
      font-weight: 200;
      pointer-events: none;
      letter-spacing: 0.5vw;
    }

    #scoreBoard span {
      display: inline-block;
      transition: transform 0.1s ease-out;
    }

    /* Game Over Screen */
    #gameOverScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      color: #fff;
    }

    #gameOverScreen.show {
      display: flex;
    }

    #winnerText {
      font-size: 6vw;
      font-weight: 300;
      letter-spacing: 0.3vw;
      animation: winner-pulse 0.5s ease-in-out 3;
      text-align: center;
      padding: 0 2vw;
    }

    @keyframes winner-pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    #gameOverScreen .subtitle {
      font-size: 2vw;
      font-weight: 300;
      margin-top: 3vh;
      animation: pulse 1.5s infinite;
    }

    #explosionCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .centerLine {
      stroke: rgba(255, 255, 255, 0.15);
      stroke-width: 1;
      stroke-dasharray: 10, 10;
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <img id="adeprimoLogo" src="/adeprimo_logo.svg" alt="Adeprimo">

    <!-- Waiting Screen -->
    <div id="waitingScreen">
      <h1>PONG</h1>
      <p id="waitingText">Waiting for players...</p>
      <div id="joinUrl" style="font-size: 6vw; margin-top: 60px; font-weight: 500; letter-spacing: 0.3vw; opacity: 0.9;"></div>
      <div id="countdown" style="font-size: 64px; margin-top: 40px; font-weight: 200; display: none;"></div>
    </div>

    <!-- Lobby Screen -->
    <div id="lobbyScreen">
      <h1 id="lobbyTitle">READY TO PLAY</h1>
      <div id="playerList">
        <div class="team-column left">
          <h2>TEAM LEFT</h2>
          <div class="player-slot" data-slot="left1">Player 1</div>
          <div class="player-slot" data-slot="left2">Player 2</div>
        </div>
        <div class="team-column right">
          <h2>TEAM RIGHT</h2>
          <div class="player-slot" data-slot="right1">Player 3</div>
          <div class="player-slot" data-slot="right2">Player 4</div>
        </div>
      </div>
      <div id="readyStatus">READY: 0/4</div>
    </div>

    <!-- Game Screen -->
    <div id="gameScreen">
      <canvas id="gameCanvas" width="1920" height="1080"></canvas>
      <div id="scoreBoard">
        <span id="leftScore">0</span>
        <span id="rightScore">0</span>
      </div>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOverScreen">
      <canvas id="explosionCanvas"></canvas>
      <div id="winnerText">TEAM LEFT WINS</div>
      <div class="subtitle">Next players loading...</div>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    let gameState = null;
    let currentState = 'WAITING';

    // Display join URL on waiting screen
    document.getElementById('joinUrl').textContent = window.location.hostname;

    // Visual effects
    let ballTrail = [];
    let particles = [];
    let shakeX = 0;
    let shakeY = 0;
    let shakeDecay = 0;
    let previousBallVX = 0;

    // New effect variables
    let speedLines = [];
    let paddleGlows = {}; // { slot: { intensity, decay } }
    let impactFlash = 0;
    let slowMotion = false;
    let slowMotionEnd = 0;
    let lastScore = { left: 0, right: 0 };
    let scorePulse = { left: 0, right: 0 };

    // Screen elements
    const waitingScreen = document.getElementById('waitingScreen');
    const lobbyScreen = document.getElementById('lobbyScreen');
    const gameScreen = document.getElementById('gameScreen');
    const gameOverScreen = document.getElementById('gameOverScreen');

    function showScreen(state) {
      currentState = state;

      waitingScreen.classList.remove('show');
      lobbyScreen.classList.remove('show');
      gameScreen.classList.remove('show');
      gameOverScreen.classList.remove('show');

      switch(state) {
        case 'WAITING':
          waitingScreen.classList.add('show');
          break;
        case 'LOBBY':
          lobbyScreen.classList.add('show');
          break;
        case 'PLAYING':
          gameScreen.classList.add('show');
          break;
        case 'GAME_OVER':
          gameOverScreen.classList.add('show');
          break;
      }
    }

    // Socket listeners
    socket.on('stateChange', (data) => {
      showScreen(data.state);
    });

    socket.on('lobbyUpdate', (data) => {
      document.getElementById('readyStatus').textContent = `READY: ${data.readyCount}/${data.totalPlayers}`;

      // Reset all slots first
      document.querySelectorAll('.player-slot').forEach(slot => {
        slot.textContent = 'Empty';
        slot.classList.remove('ready');
        slot.style.opacity = '0.3';
      });

      // Update player slots
      data.players.forEach(player => {
        const slot = document.querySelector(`[data-slot="${player.slot}"]`);
        if (slot) {
          slot.textContent = player.nickname.toUpperCase();
          slot.style.opacity = '1';
          if (player.ready) {
            slot.classList.add('ready');
          } else {
            slot.classList.remove('ready');
          }
        }
      });
    });

    socket.on('gameStart', () => {
      showScreen('PLAYING');
    });

    socket.on('gameState', (state) => {
      if (currentState === 'PLAYING') {
        // Detect paddle collision (ball direction changed)
        if (gameState && gameState.ball && Math.sign(state.ball.vx) !== Math.sign(previousBallVX) && previousBallVX !== 0) {
          const speed = Math.sqrt(state.ball.vx * state.ball.vx + state.ball.vy * state.ball.vy);

          // Create particles
          const particleCount = Math.min(Math.floor(speed / 2), 10);
          for (let i = 0; i < particleCount; i++) {
            particles.push({
              x: state.ball.x,
              y: state.ball.y,
              vx: -state.ball.vx * 0.3 + (Math.random() - 0.5) * 3,
              vy: (Math.random() - 0.5) * 8,
              radius: Math.random() * 3 + 2,
              opacity: 1
            });
          }

          // Screen shake
          shakeDecay = Math.min(speed, 15);

          // Impact flash (stronger for faster hits)
          impactFlash = Math.min(speed / 25, 0.3);

          // Paddle glow - find which paddle was hit
          const isLeftSide = state.ball.vx > 0;
          if (state.activeSlots) {
            state.activeSlots.forEach(slot => {
              const paddle = state.paddles[slot];
              if (paddle &&
                  ((isLeftSide && paddle.team === 'left') ||
                   (!isLeftSide && paddle.team === 'right'))) {
                // Check if ball is close to this paddle
                if (Math.abs(state.ball.y - (paddle.y + paddle.height / 2)) < paddle.height) {
                  paddleGlows[slot] = { intensity: Math.min(speed / 20, 1.5), decay: 0 };
                }
              }
            });
          }
        }

        // Create speed lines based on ball speed
        if (state.ball) {
          const speed = Math.sqrt(state.ball.vx * state.ball.vx + state.ball.vy * state.ball.vy);
          if (speed > 15) { // Only show speed lines when fast
            const lineCount = Math.floor((speed - 15) / 3);
            for (let i = 0; i < lineCount; i++) {
              speedLines.push({
                x: state.ball.x + (Math.random() - 0.5) * 200,
                y: state.ball.y + (Math.random() - 0.5) * 100,
                length: Math.random() * 40 + 20,
                opacity: Math.random() * 0.6 + 0.2,
                speed: Math.sign(state.ball.vx) * (speed / 5)
              });
            }
          }
        }

        previousBallVX = state.ball.vx;
        gameState = state;
        render();
      }
    });

    socket.on('score', (score) => {
      document.getElementById('leftScore').textContent = score.left;
      document.getElementById('rightScore').textContent = score.right;

      // Trigger score pulse animation
      if (score.left > lastScore.left) {
        scorePulse.left = 1.5;
      }
      if (score.right > lastScore.right) {
        scorePulse.right = 1.5;
      }

      // Trigger slow motion effect
      slowMotion = true;
      slowMotionEnd = Date.now() + 500;

      lastScore = { left: score.left, right: score.right };
    });

    socket.on('gameOver', (data) => {
      const winnerText = data.winner === 'left' ? 'TEAM LEFT WINS' : 'TEAM RIGHT WINS';
      document.getElementById('winnerText').textContent = winnerText;
      showScreen('GAME_OVER');
      startExplosion();
    });

    // Explosion effect
    function startExplosion() {
      const explosionCanvas = document.getElementById('explosionCanvas');
      explosionCanvas.width = window.innerWidth;
      explosionCanvas.height = window.innerHeight;
      const ctx = explosionCanvas.getContext('2d');

      const particles = [];
      const particleCount = 100;
      const centerX = explosionCanvas.width / 2;
      const centerY = explosionCanvas.height / 2;

      // Create particles
      for (let i = 0; i < particleCount; i++) {
        particles.push({
          x: centerX,
          y: centerY,
          vx: (Math.random() - 0.5) * 20,
          vy: (Math.random() - 0.5) * 20,
          radius: Math.random() * 10 + 5,
          opacity: 1
        });
      }

      // Animate particles
      function animateExplosion() {
        ctx.clearRect(0, 0, explosionCanvas.width, explosionCanvas.height);

        let anyAlive = false;
        particles.forEach(p => {
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.3; // Gravity
          p.opacity -= 0.02;

          if (p.opacity > 0) {
            anyAlive = true;
            ctx.fillStyle = `rgba(255, 255, 255, ${p.opacity})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
            ctx.fill();
          }
        });

        if (anyAlive) {
          requestAnimationFrame(animateExplosion);
        }
      }

      animateExplosion();
    }

    socket.on('lobbyTimer', (data) => {
      const countdownEl = document.getElementById('countdown');
      if (data.countdown > 0) {
        countdownEl.textContent = `Starting in ${data.countdown}s`;
        countdownEl.style.display = 'block';
      } else {
        countdownEl.style.display = 'none';
      }
    });

    function render() {
      if (!gameState || currentState !== 'PLAYING') return;

      // Apply screen shake
      ctx.save();
      ctx.translate(shakeX, shakeY);

      // Clear canvas
      ctx.fillStyle = '#000';
      ctx.fillRect(-shakeX, -shakeY, canvas.width, canvas.height);

      // Draw impact flash (full screen white overlay)
      if (impactFlash > 0) {
        ctx.fillStyle = `rgba(255, 255, 255, ${impactFlash})`;
        ctx.fillRect(-shakeX, -shakeY, canvas.width, canvas.height);
      }

      // Draw speed lines
      speedLines.forEach(line => {
        ctx.strokeStyle = `rgba(255, 255, 255, ${line.opacity})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(line.x, line.y);
        ctx.lineTo(line.x + line.length, line.y);
        ctx.stroke();
      });

      // Calculate ball speed for dynamic sizing
      const ballSpeed = gameState.ball ? Math.sqrt(gameState.ball.vx * gameState.ball.vx + gameState.ball.vy * gameState.ball.vy) : 0;
      const ballSizeMultiplier = Math.min(1 + (ballSpeed - 10) / 40, 1.5);
      const dynamicBallRadius = gameState.ball.radius * ballSizeMultiplier;

      // Draw enhanced ball trail
      const maxTrailLength = Math.min(8 + Math.floor(ballSpeed / 3), 15);
      ballTrail.forEach((pos, index) => {
        const alpha = (index / ballTrail.length) * 0.5;
        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, dynamicBallRadius * 0.7, 0, Math.PI * 2);
        ctx.fill();
      });

      // Draw center line
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
      ctx.setLineDash([10, 10]);
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2, 0);
      ctx.lineTo(canvas.width / 2, canvas.height);
      ctx.stroke();
      ctx.setLineDash([]);

      // Draw obstacles
      if (gameState.obstacles) {
        ctx.fillStyle = '#fff';
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        gameState.obstacles.forEach(obstacle => {
          ctx.beginPath();
          ctx.arc(obstacle.x, obstacle.y, obstacle.radius, 0, Math.PI * 2);
          ctx.stroke();
        });
      }

      // Draw paddles (white) with glow - only for active players
      if (gameState.activeSlots) {
        gameState.activeSlots.forEach(slot => {
          const paddle = gameState.paddles[slot];
          if (paddle) {
            // Draw glow if active
            if (paddleGlows[slot] && paddleGlows[slot].intensity > 0) {
              ctx.shadowColor = '#fff';
              ctx.shadowBlur = paddleGlows[slot].intensity * 40;
              ctx.fillStyle = '#fff';
            } else {
              ctx.fillStyle = '#fff';
              ctx.shadowBlur = 0;
            }
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
            ctx.shadowBlur = 0;
          }
        });
      }

      // Draw particles
      particles.forEach(p => {
        ctx.fillStyle = `rgba(255, 255, 255, ${p.opacity})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fill();
      });

      // Draw ball (white with subtle shadow and dynamic size)
      ctx.fillStyle = '#fff';
      ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
      ctx.shadowBlur = 10 + (ballSpeed / 5);
      ctx.beginPath();
      ctx.arc(gameState.ball.x, gameState.ball.y, dynamicBallRadius, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      ctx.restore();

      // Update ball trail with dynamic length
      if (gameState.ball) {
        ballTrail.push({ x: gameState.ball.x, y: gameState.ball.y });
        while (ballTrail.length > maxTrailLength) ballTrail.shift();
      }

      // Update speed lines
      speedLines = speedLines.filter(line => {
        line.x += line.speed;
        line.opacity -= 0.05;
        return line.opacity > 0 && line.x > -100 && line.x < canvas.width + 100;
      });

      // Update paddle glows
      Object.keys(paddleGlows).forEach(slot => {
        const glow = paddleGlows[slot];
        glow.decay += 0.05;
        glow.intensity = Math.max(0, glow.intensity - glow.decay);
        if (glow.intensity <= 0) {
          delete paddleGlows[slot];
        }
      });

      // Update impact flash
      if (impactFlash > 0) {
        impactFlash *= 0.85;
        if (impactFlash < 0.01) impactFlash = 0;
      }

      // Update particles
      particles = particles.filter(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.vy += 0.5; // Gravity
        p.opacity -= 0.02;
        return p.opacity > 0;
      });

      // Update screen shake
      if (shakeDecay > 0) {
        shakeDecay *= 0.9;
        shakeX = (Math.random() - 0.5) * shakeDecay;
        shakeY = (Math.random() - 0.5) * shakeDecay;
        if (shakeDecay < 0.5) {
          shakeDecay = 0;
          shakeX = 0;
          shakeY = 0;
        }
      }
    }

    // Animation loop
    function animate() {
      if (currentState === 'PLAYING') {
        render();
      }

      // Update score pulse animation
      const leftScoreEl = document.getElementById('leftScore');
      const rightScoreEl = document.getElementById('rightScore');

      if (scorePulse.left > 1) {
        scorePulse.left -= 0.05;
        leftScoreEl.style.transform = `scale(${scorePulse.left})`;
        leftScoreEl.style.textShadow = `0 0 ${(scorePulse.left - 1) * 40}px #fff`;
      } else {
        leftScoreEl.style.transform = 'scale(1)';
        leftScoreEl.style.textShadow = 'none';
      }

      if (scorePulse.right > 1) {
        scorePulse.right -= 0.05;
        rightScoreEl.style.transform = `scale(${scorePulse.right})`;
        rightScoreEl.style.textShadow = `0 0 ${(scorePulse.right - 1) * 40}px #fff`;
      } else {
        rightScoreEl.style.transform = 'scale(1)';
        rightScoreEl.style.textShadow = 'none';
      }

      // Check slow motion end
      if (slowMotion && Date.now() > slowMotionEnd) {
        slowMotion = false;
      }

      requestAnimationFrame(animate);
    }

    animate();
  </script>
</body>
</html>
